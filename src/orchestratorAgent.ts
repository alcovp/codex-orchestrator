import { Agent, run } from "@openai/agents"
import path from "node:path"
import { mkdir } from "node:fs/promises"
import {
    buildOrchestratorContext,
    resolveRepoRoot,
    type OrchestratorContext,
} from "./orchestratorTypes.js"
import { codexPlanTaskTool } from "./tools/codexPlanTaskTool.js"
import { codexRunSubtaskTool } from "./tools/codexRunSubtaskTool.js"
import { codexMergeResultsTool } from "./tools/codexMergeResultsTool.js"
import { runRepoCommandTool } from "./tools/runRepoCommandTool.js"
import { resolveBaseBranch } from "./baseBranch.js"
import { appendJobLog, setJobLogPath } from "./jobLogger.js"
import { resolveDbPath } from "./db/sqliteDb.js"

export interface OrchestratorRunOptions {
    /**
     * High-level task description for the orchestrator, e.g.
     * "Add /api/v1/users/search endpoint and write tests".
     */
    taskDescription: string

    /**
     * Absolute path to the directory containing all worktrees (defaults to env).
     */
    baseDir?: string
    /**
     * Absolute path to the target repository (overrides baseDir/env/cwd).
     */
    repoRoot?: string
    /**
     * Optional flag to push the merged result branch to origin.
     */
    pushResult?: boolean

    /**
     * Optional job identifier; defaults to ORCHESTRATOR_JOB_ID or autogenerated.
     */
    jobId?: string

    /**
     * Base branch for all worktrees (default: main).
     */
    baseBranch?: string
}

const orchestratorAgent = new Agent<OrchestratorContext>({
    name: "Codex Orchestrator",
    model: "gpt-5.1",
    instructions: `
You are the Codex Orchestrator. You are intentionally dumb: do NOT write code, do NOT analyze source files, do NOT improvise implementation details. Your job is only to call tools and pass JSON between them.

Protocol (for any dev request):
1) Always call codex_plan_task first with the user task and project_root = repo root to get a JSON plan.
2) For each subtask from the plan, call codex_run_subtask (context already provides job_id/base_branch/result_branch). Pass user_task=<original request> so the worker keeps full context. Group by parallel_group when plan.can_parallelize=true (subtasks with the same parallel_group can run in parallel; otherwise run sequentially). Use worktree names like "task-<slug>".
3) Collect subtask outputs as an array of { subtask_id, worktree_path (absolute), branch, summary } and call codex_merge_results (context already provides job_id/base_branch/result_branch). Merge happens in the result branch/worktree (.codex/jobs/<jobId>/worktrees/result); pushes are disabled by default, but if context.pushResult=true the merge tool will push the result branch to origin.
4) Final reply to the user MUST be derived from the merge JSON only: status + touched_files + notes (if any). Do not invent code details or add extra commentary beyond that summary.

Working layout:
- Repo root is context.repoRoot (no extra main/ folder).
- Worktrees are under .codex/jobs/<jobId>/worktrees/task-<...>; each subtask gets its own branch.
- Shared result branch (default: result-<jobId>) is created once per job and used for the final merge; commits stay local.

Example skeleton (pseudocode):
- plan = codex_plan_task({ project_root: "<repo-root>", user_task })
- batches: if plan.can_parallelize then group by parallel_group else run sequentially
- For each batch: run codex_run_subtask for each subtask in parallel (job_id=context.jobId); collect { subtask_id, worktree_path (absolute), branch, summary }
- merge = codex_merge_results({ project_root: "<repo-root>", job_id: context.jobId, base_branch: context.baseBranch, result_branch: context.resultBranch, subtasks_results })
- Final reply: merge JSON as text (status, notes, touched_files)

Verbose logging requirements (respond in plain text):
- After planner: print "PLAN (N subtasks)" and embed the JSON plan (full or truncated if huge).
- For each subtask: log "SUBTASK <id> @ <worktree> -> <status>" and include the returned JSON summary.
- Before merge: show the array you pass into codex_merge_results (subtask_id/worktree_path/branch/summary).
- After merge: print the merge JSON (status/notes/touched_files).
- Final reply: reiterate merge status + touched_files + notes; keep it concise but include counts (subtasks total/completed).

Constraints:
- Never skip codex_plan_task on dev work.
- Never return early without running the tools above.
- Use run_repo_command only for basic git/shell helpers if absolutely necessary; prefer codex_* tools.
`,
    tools: [runRepoCommandTool, codexPlanTaskTool, codexRunSubtaskTool, codexMergeResultsTool],
})

type RunImplementation = typeof run
let runImplementation: RunImplementation = run

// For testing: allow injecting a mock run implementation.
export function setRunImplementationForTesting(fn: RunImplementation) {
    runImplementation = fn
}

export async function runOrchestrator(options: OrchestratorRunOptions): Promise<string> {
    const repoRoot = resolveRepoRoot(options.repoRoot ?? options.baseDir)
    const baseBranch = await resolveBaseBranch({ repoRoot, explicitBranch: options.baseBranch })
    const context = buildOrchestratorContext({
        repoRoot,
        baseBranch,
        jobId: options.jobId,
        taskDescription: options.taskDescription,
        userTask: options.taskDescription,
        pushResult: options.pushResult,
    })

    const jobLogPath = path.join(context.jobsRoot, "orchestrator.log")
    await mkdir(context.jobsRoot, { recursive: true })
    setJobLogPath(jobLogPath)
    const dbPath = resolveDbPath()

    const header = [
        `[orchestrator] job ${context.jobId}`,
        `repo=${context.repoRoot}`,
        `base_branch=${context.baseBranch}`,
        `db=${dbPath}`,
        `log=${jobLogPath}`,
    ].join(" | ")
    console.log(header)
    await appendJobLog(header)

    try {
        console.log(`[orchestrator] planning with codex_plan_task...`)
        await appendJobLog("planning: start codex_plan_task")
        const result = await runImplementation(orchestratorAgent, options.taskDescription, {
            context,
            maxTurns: 30,
        })
        const output = result.finalOutput ?? ""
        await appendJobLog(`ORCHESTRATOR OUTPUT:\n${output}`)
        return output
    } catch (error) {
        console.error("Failed to run orchestrator agent:", error)
        if (error instanceof Error) {
            await appendJobLog(`ORCHESTRATOR ERROR: ${error.message}`)
        }
        throw error
    } finally {
        setJobLogPath(null)
    }
}
